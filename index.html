<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Retro LCD Photo Editor (HTML)</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #eee; text-align: center; }
    #canvasContainer { width: 960px; max-height: 540px; overflow: auto; margin: 0 auto; border: 2px solid #444; background: #000; }
    canvas { display: block; margin: 0 auto; }
    .controls { margin: 10px auto; width: 960px; text-align: left; }
    .slider-group, .text-group { margin: 10px 0; }
    input[type=range], input[type=text], select { width: 100%; }
  </style>
</head>
<body>
  <h1>üïπÔ∏è Retro LCD Photo Editor</h1>
  <input type="file" id="upload" accept="image/*"><br>
  <div id="canvasContainer"><canvas id="canvas"></canvas></div>

  <div class="controls">
    <div class="slider-group">
      <label>Noise Level: <span id="noiseVal">15</span>%</label>
      <input type="range" id="noise" min="0" max="100" value="15">
    </div>
    <div class="slider-group">
      <label>Random Image Noise Generator</label>
      <button id="generateNoise">üé≤ Generate New Noise</button>
    </div>
    <div class="slider-group">
      <label>Quality (Pixelate): <span id="qualityVal">4</span></label>
      <input type="range" id="quality" min="1" max="20" value="4">
    </div>
    <div class="slider-group">
      <label>Line Intensity: <span id="linesVal">30</span></label>
      <input type="range" id="lines" min="0" max="255" value="30">
    </div>
    <div class="slider-group">
      <label>Glitch Strength: <span id="glitchVal">5</span></label>
      <input type="range" id="glitch" min="0" max="30" value="5">
    </div>
    <div class="slider-group">
      <label>Grid Noise Overlay (Intensity): <span id="gridVal">10</span></label>
      <input type="range" id="grid" min="0" max="100" value="10">
    </div>
    <div class="slider-group">
      <label>Lens Distortion (Radial): <span id="lensVal">0</span></label>
      <input type="range" id="lens" min="-1" max="1" step="0.01" value="0">
    </div>
    <div class="slider-group">
      <label>Noise Color (RGB Tint):</label>
      <input type="color" id="noiseColor" value="#ff0000">
    </div>
    <div class="slider-group">
      <label>Flicker Intensity: <span id="flickerVal">3</span></label>
      <input type="range" id="flicker" min="0" max="10" value="3">
    </div>
    <div class="text-group">
      <label>Caption Text:</label>
      <input type="text" id="captionText" value="THE TRUTH IS OUT THERE">
      <label>Text Glitch Strength: <span id="captionGlitchVal">3</span></label>
      <input type="range" id="captionGlitch" min="0" max="20" value="3">
      <label>Caption X Position (%): <span id="captionXVal">50</span></label>
      <input type="range" id="captionX" min="0" max="100" value="50">
      <label>Caption Y Position (%): <span id="captionYVal">90</span></label>
      <input type="range" id="captionY" min="0" max="100" value="90">
    </div>
    <div class="slider-group">
      <label>Export Format:</label>
      <select id="format">
        <option value="png">PNG</option>
        <option value="jpeg">JPEG</option>
        <option value="gif">GIF (animated flicker)</option>
      </select>
    </div>
    <button id="save">üíæ Export</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const temp = document.createElement('canvas');
    const tctx = temp.getContext('2d');
    let originalImage = null;
    let noiseSeed = Math.random();

    const sliders = ['noise', 'quality', 'lines', 'glitch', 'grid', 'lens', 'captionGlitch', 'captionX', 'captionY', 'flicker'];
    const inputs = sliders.map(id => document.getElementById(id));
    const values = sliders.reduce((obj, id) => {
      obj[id] = () => parseFloat(document.getElementById(id).value);
      return obj;
    }, {});
    const noiseColorInput = document.getElementById('noiseColor');
    const captionText = document.getElementById('captionText');
    const formatSelect = document.getElementById('format');

    function updateValueLabels() {
      sliders.forEach(id => {
        const label = document.getElementById(id + 'Val');
        if (label) label.textContent = document.getElementById(id).value;
      });
      document.getElementById('captionXVal').textContent = values.captionX();
      document.getElementById('captionYVal').textContent = values.captionY();
    }

    document.getElementById('generateNoise').onclick = () => {
      noiseSeed = Math.random();
      renderFrame();
    };

    function randomWithSeed(seed, index) {
      return ((Math.sin(seed * 1000 + index * 1337) + 1) / 2);
    }

    function renderFrame(flicker = false) {
      updateValueLabels();
      const w = originalImage.naturalWidth;
      const h = originalImage.naturalHeight;
      const quality = values.quality();
      const noiseLevel = values.noise();
      const lineIntensity = values.lines();
      const glitchStrength = values.glitch();
      const gridIntensity = values.grid();
      const lens = values.lens();
      const flickerLevel = flicker ? values.flicker() : 0;
      const captionGlitchLevel = values.captionGlitch();
      const caption = captionText.value;
      const captionXPercent = values.captionX();
      const captionYPercent = values.captionY();
      const noiseColor = hexToRgb(noiseColorInput.value);

      canvas.width = temp.width = w;
      canvas.height = temp.height = h;

      tctx.drawImage(originalImage, 0, 0);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(temp, 0, 0, w / quality, h / quality, 0, 0, w, h);

      let imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;

      for (let i = 0; i < data.length; i += 4) {
        const gray = 0.3 * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
        data[i] = data[i + 1] = data[i + 2] = gray;
        const n = (randomWithSeed(noiseSeed, i) - 0.5) * noiseLevel;
        data[i] += n * (noiseColor.r / 255);
        data[i + 1] += n * (noiseColor.g / 255);
        data[i + 2] += n * (noiseColor.b / 255);
      }

      for (let y = 0; y < h; y += 3) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          data[idx] = Math.max(0, data[idx] - lineIntensity);
          data[idx + 1] = Math.max(0, data[idx + 1] - lineIntensity);
          data[idx + 2] = Math.max(0, data[idx + 2] - lineIntensity);
        }
      }

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          if ((x + y) % 4 === 0) {
            const idx = (y * w + x) * 4;
            data[idx] += gridIntensity;
            data[idx + 1] += gridIntensity;
            data[idx + 2] += gridIntensity;
          }
        }
      }

      ctx.putImageData(imgData, 0, 0);

      // Timestamp (restored original font size, lowered position)
      ctx.font = '20px monospace';
      ctx.fillStyle = flickerLevel ? `rgba(255,255,255,${1 - Math.random() * flickerLevel / 10})` : 'white';
      const ts = new Date().toLocaleString();
      ctx.shadowColor = 'black';
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.shadowBlur = 2;
      ctx.fillText(ts, 10, h - 10);
      ctx.shadowColor = 'transparent';

      // Caption
      ctx.font = '42px Impact, sans-serif';
      ctx.fillStyle = 'yellow';
      ctx.shadowColor = 'black';
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.shadowBlur = 3;
      const cx = (captionXPercent / 100) * w;
      const cy = (captionYPercent / 100) * h;
      ctx.fillText(caption, cx, cy);
      ctx.shadowColor = 'transparent';

      for (let i = 0; i < captionGlitchLevel; i++) {
        const ry = Math.floor(Math.random() * 20);
        const slice = ctx.getImageData(cx, cy - 30 + ry, 300, 1);
        ctx.putImageData(slice, cx + Math.random() * 10 - 5, cy - 30 + ry);
      }
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.replace('#', ''), 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    }

    document.getElementById('upload').onchange = function (e) {
      const reader = new FileReader();
      reader.onload = function (event) {
        const img = new Image();
        img.onload = function () {
          originalImage = img;
          renderFrame();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    };

    inputs.forEach(el => el.addEventListener('input', () => renderFrame()));
    captionText.addEventListener('input', () => renderFrame());

    document.getElementById('save').onclick = async () => {
      const format = formatSelect.value;
      if (format === 'gif') {
        const gif = new GIF({ workers: 2, quality: 10, width: canvas.width, height: canvas.height });
        for (let i = 0; i < 10; i++) {
          renderFrame(true);
          gif.addFrame(canvas, { copy: true, delay: 100 });
        }
        gif.on('finished', function (blob) {
          const link = document.createElement('a');
          link.download = 'flicker.gif';
          link.href = URL.createObjectURL(blob);
          link.click();
        });
        gif.render();
      } else {
        renderFrame();
        const link = document.createElement('a');
        link.download = 'retro_image.' + format;
        link.href = canvas.toDataURL('image/' + format);
        link.click();
      }
    };
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</body>
</html>
